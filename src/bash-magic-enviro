# Main Bash Magic Enviro manager
#
# This file is meant to be sourced, not run
BME_SRC_DIR='/home/jmnav/REPOS/bash-magic-enviro'
BME_VERSION='v1.2.0'
# BME_SRC_DIR=<% BME_SRC_DIR %>
# BME_VERSION=<% BME_VERSION %>
BME_PROJECT_FILE='.bme_project'
BME_FILE='.bme_env'
BME_HIDDEN_DIR='.bme.d'
BME_CONFIG_DIR="${HOME}/${BME_HIDDEN_DIR}"
BME_WHITELISTED_FILE="${BME_CONFIG_DIR}/whitelistedpaths.txt"

# Style table
export C_BOLD='\033[1m'         # Bold text
export C_GREEN='\033[1;32m'     # Green (and bold)
export C_YELLOW='\033[1;1;33m'  # Yellow (and bold)
export C_RED='\033[1;31m'       # Red (and bold)
export C_NC='\033[0m'           # No Color

# Sets 'fake' boolean
declare -i BOOL=(0 1)
true=${BOOL[0]}
false=${BOOL[1]}

DEBUG=$true

#--
# FUNCTIONS
#--
# Main BME loader (it runs each time we change directory as per PROMPT_COMMAND)
# it first looks for a "project file" (.bme_project), then for a "config file" (.bme_env)
bme_eval_dir() {
	if [ "$PWD" != "$MYOLDPWD" ]; then
		MYOLDPWD="$PWD"
		if [ -e ${BME_PROJECT_FILE} ]; then
			if [[ -n ${BME_PROJECT_DIR+x} ]]; then
			# A new ${BME_PROJECT_FILE} found, but already within a project
				__bme_clean_project || return $?
			fi
			if __bme_whitelist "$PWD"; then
				__bme_process_known_projects "$PWD"
				__bme_load_project "$PWD"
			else
				bme_log "${C_BOLD}'${BME_PROJECT_FILE}'${C_NC} file found, but load was rejected (see ${C_BOLD}'${BME_WHITELISTED_FILE}'${C_NC} contents)." warning
			fi
		fi
	# this conditional matches when we go "above" the project's root directory
		if [ "${PWD##$BME_PROJECT_DIR}" == "$PWD" ] && [[ -n ${BME_PROJECT_DIR+x} ]]; then
			__bme_clean_project || return $?
		# now, check if current dir belongs to an already known project
			local project
			for project in "${!BME_LOADED_PROJECTS[@]}"; do
				local project_root_dir="${BME_LOADED_PROJECTS[${project}]}"
				if ! [ "${PWD##$project_root_dir}" == "$PWD" ]; then
				# Within an already known project
					__bme_debug && echo "WITHIN PROJECT AT '${project_root_dir}'"
					if __bme_whitelist "${project_root_dir}"; then
						__bme_load_project "${project_root_dir}"
					fi
					unset project
					break
				fi
			done
		fi
	# One way or the other, ${BME_PROJECT_FILE} is already processed when reaching this point.
	# time now for the ${BME_FILE}
		if [ -e ${BME_FILE} ] && [[ -n ${BME_PROJECT_NAME+x} ]]; then
			__bme_debug && echo "${BME_FILE} FOUND"
			source ${BME_FILE}
		fi
	fi
	
# 		if [ -e ${BME_FILE} ]; then
# 			if __bme_whitelist "$PWD"; then
# 				__load_project
# 				source ${BME_FILE}
# 				# PROJECT_NAME must be the first thing to be set!!!
# 				if [[ -z ${BME_PROJECT_NAME+x} ]]; then
# 					local log_msg="You didn't set ${C_BOLD}'BME_PROJECT_NAME=[your_project_name]'${C_NC} in your ${C_BOLD}'${BME_PROJECT_FILE}'${C_NC} file.\n"
# 					log_msg+="\tDid you stop by your project's root directory first?"
# 					bme_log "${log_msg}" fatal
# 					return -1
# 				elif [[ -z ${PROJECT_DIR+x} ]]; then
# 					__bme_check_project_name "${BME_PROJECT_NAME}" || return $?
# 					# if a variable named after the project doesn't exist, it's because we just entered a new project environment
# 					if ! [ -v ${BME_PROJECT_NAME}[@] ]; then
# 						echo "VAR DOES NOT EXIST"
# 						__load_project ${BME_PROJECT_NAME}
# 					else
# 						echo "VAR DOES EXIST: ${!BME_PROJECT_NAME}"
# 						declare -n current_project=${BME_PROJECT_NAME}
# 						for key in "${!current_project[@]}"; do
# 							echo "$key => ${current_project[$key]}"
# 						done
# 					fi
# 				# If PROJECT_DIR is not set, it's because we just entered a new project enviroment
# 					__load_project
# 				fi
# 			else
# 				bme_log "${C_BOLD}'${BME_FILE}'${C_NC} file found, but load was rejected (see ${C_BOLD}'${BME_WHITELISTED_FILE}'${C_NC} contents)." warning
# 			fi
# 		fi
# 	# this conditional matches when we go "above" the project's root directory
# 		if [ "${PWD##$PROJECT_DIR}" == "$PWD" ] && [[ -n ${PROJECT_DIR+x} ]]; then
# 			__clean_project
# 		fi
# 	fi
}


# A quick-set for debug messages
__bme_debug() {
	if [[ -n ${DEBUG} && $DEBUG == $true ]]; then
		return ${DEBUG}
	else
		return ${false}
	fi
}


# Logger function
# 1st param: 'log_message': the log message itself
# 2st param: 'log_type': log prefix, i.e.: ERROR, WARNING, empty string...
# 3st param: 'log_level': sets the indentation level of the log output, starting '0'
bme_log() {
local log_message="${1}"  # first param
local log_type="${2^^}"   # second param (uppercased)
local log_level=${3:-0}   # third param (with a default of 0)
local full_message=''
# Params debug
# 	echo "log_message: ${log_message}"
# 	echo "log_type: ${log_type}"
# 	echo "log_level: ${log_level}"

	# No parameters.  Show help instead
	if (( $# == 0 )); then
		local log_msg="'log message' ['log type' (see below)] [indentation level (0,1,2...)]"
		log_msg+="\n${C_BOLD}'log type'${C_NC} will add a colored prefix as shown below:"
		log_msg+="\n\t${C_GREEN}'INFO|OK|LOADING|CLEANING|FUNCTION'${C_NC}"
		log_msg+="\n\t${C_YELLOW}'WARNING'${C_NC}"
		log_msg+="\n\t${C_RED}'FATAL|ERROR|FAIL'${C_NC}"
		log_msg+="\n\t${C_BOLD}'any other log type'${C_NC}"
		log_msg+="\n${C_BOLD}Color codes you can use in your messages:${C_NC}"
		log_msg+="\n\t\"\${C_BOLD}${C_BOLD}'BOLD'${C_NC}\${C_NC}\""
		log_msg+="\n\t\"\${C_GREEN}${C_GREEN}'GREEN'${C_NC}\${C_NC}\""
		log_msg+="\n\t\"\${C_YELLOW}${C_YELLOW}'YELLOW'${C_NC}\${C_NC}\""
		log_msg+="\n\t\"\${C_RED}${C_RED}'RED'${C_NC}\${C_NC}\""
		bme_log "${log_msg}" ${FUNCNAME[0]}
		return 0
	fi
	
	# standard log message processing
	if [ -z "$log_message" ]; then
		echo -e "${C_RED}FATAL:${C_NC} ${C_BOLD}'${FUNCNAME[0]}'${C_NC} called in code from ${C_BOLD}'${FUNCNAME[1]}'${C_NC} with no message."
		return -1
	fi
# Sets indentation level
	for (( i=0; i < ${log_level}; i++ )); do
		full_message+='\t'
	done
	unset i
# Then, message type
	case "$log_type" in
		FATAL | ERROR | FAIL)
			full_message+="${C_RED}${log_type}:${C_NC} "
		;;
		WARNING)
			full_message+="${C_YELLOW}${log_type}:${C_NC} "
		;;
		INFO | OK \
		| LOADING | CLEANING \
		| FUNCTION)
			full_message+="${C_GREEN}${log_type}:${C_NC} "
		;;
		*)
			if [ -n "$log_type" ]; then
				full_message+="${C_BOLD}${log_type}:${C_NC} "
			fi
		;;
	esac
# Finally, the message itself
	full_message+="${log_message}"
	
	echo -e "${full_message}"
}
export -f bme_log


# Manages array of known projects
# 1st param: 'project_dir': the directory to look for a project file
__bme_process_known_projects() {
local project_dir="${1}"

# Just once, on a new "BME session"
	if ! [ -v BME_LOADED_PROJECTS[@] ]; then
		__bme_debug && echo "Creating BME_LOADED_PROJECTS"
		declare -Ag BME_LOADED_PROJECTS
	fi
# Loads the new project file in a subshell to check if it's a new project
	local new_project=$(source "${project_dir}/${BME_PROJECT_FILE}" && echo "${BME_PROJECT_NAME}")
	if [[ -z "${new_project}" ]]; then
		bme_log "You didn't set ${C_BOLD}'BME_PROJECT_NAME=[your_project_name]'${C_NC} in your ${C_BOLD}'${BME_PROJECT_FILE}'${C_NC} file." fatal
		return -1
	fi
	
	if ! [ -v BME_LOADED_PROJECTS["${new_project}"] ]; then
		__bme_debug && echo "${new_project} not listed."
		__bme_check_project_name "${new_project}" || return $?
		BME_LOADED_PROJECTS["${new_project}"]+="${PWD}"
		__bme_debug && echo "new root project: ${BME_LOADED_PROJECTS[${new_project}]}"
	else
		__bme_debug && echo "root project already known: ${BME_LOADED_PROJECTS[${new_project}]}"
	fi
	__bme_debug && echo "Currently known projects:" `typeset -p BME_LOADED_PROJECTS`
}


# Loads a project's configuration
# 1st param: 'project_dir': the directory to look for a project file
__bme_load_project() {
local project_dir="${1}"

# A bit of debug: I need to know the place I'm stored, so I can find other includes, relative to me
# 	echo "See what follows: $0"
# 	echo "See what follows: $_"
# 	echo "See what follows: ${BASH_SOURCE}"  # This is the good one! ~/bin/bash-magic-enviro
# 	echo "See what follows: ${BASH_SOURCE[0]}"
# 	echo "See what follows: ${BASH_SOURCE[${#BASH_SOURCE[@]} - 1]}"
# 	echo "See what follows: ${FUNCNAME[@]}"

# "pseudo private" function protection
	if [ "${FUNCNAME[1]}" != 'bme_eval_dir' ]; then
		bme_log "Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} is ${C_BOLD}private${C_NC}.  You shouldn't invoke it!" error
		return -1
	fi
	
	# if $BME_PROJECT_NAME is defined, we are already within a "BME session"
	if [[ -n ${BME_PROJECT_NAME+x} ]]; then
		__bme_debug && echo "ALREADY WITHIN A PROJECT ENVIRONMENT"
		return 0
# 	# Loads the new project file in a subshell to check if it's a new project
# 		local new_project=$(source "${project_dir}/${BME_PROJECT_FILE}" && echo ${BME_PROJECT_NAME})
# 		if [ ${BME_PROJECT_NAME} != ${new_project} ]; then
# 			__bme_debug && echo "ENTERING NEW PROJECT ENVIRONMENT: '${BME_PROJECT_NAME}' vs '${new_project}'"
# 			__bme_clean_project
# 				if [ ${BME_LOADED_PROJECTS[${BME_PROJECT_NAME}]+x} ]; then
# 					__bme_debug && echo "root stored: ${BME_LOADED_PROJECTS[${BME_PROJECT_NAME}]}"
# 					__bme_clean_project && source ${BME_PROJECT_FILE} && __bme_load_project
# 				else
# 					__bme_debug && echo "root not yet stored"
# 					local log_msg="Something wrong happened."
# 					log_msg+="\n\tProject ${C_BOLD}'${BME_PROJECT_NAME}'${C_NC} activated, but no root known."
# 					log_msg+="\n\tTry to replicate this circumstance and open a bug at https://github.com/jmnavarrol/bash-magic-enviro/issues."
# 					bme_log "${log_msg}" error
# 				fi
# 		else
# 			__bme_debug && echo "STILL WITHIN SAME PROJECT: ${BME_PROJECT_NAME} vs ${new_project}"
# 		fi
# 		# Before even trying to load the new project environment, we need to preserve current environment
# # 		if ! [ -v ${BME_PROJECT_NAME}[@] ]; then
# # 			echo "VAR DOES NOT EXIST"
# # 		else
# # 			echo "VAR DOES EXIST: ${!BME_PROJECT_NAME}"
# # 			# Loads the new project file in a subshell to check if it's a new project
# # 		fi
# 	else
# 	# $BME_PROJECT_NAME is not yet defined, we are entering a new "BME session"
# 		__bme_debug && echo "LOADING PROJECT FROM CLEAN STATUS"
# 		__bme_debug && echo "${project_dir}/${BME_PROJECT_FILE}"
# 		source "${project_dir}/${BME_PROJECT_FILE}" && BME_PROJECT_DIR="${project_dir}"
# 		__bme_check_project_name "${BME_PROJECT_NAME}" || return $?
# 		if ! [ -v ${BME_LOADED_PROJECTS[@]} ]; then
# 			declare -Ag BME_LOADED_PROJECTS
# 		fi
# 		BME_LOADED_PROJECTS["${BME_PROJECT_NAME}"]+="${PWD}"
	fi

# 					# if a variable named after the project doesn't exist, it's because we just entered a new project environment
# 					if ! [ -v ${BME_PROJECT_NAME}[@] ]; then
# 						echo "VAR DOES NOT EXIST"
# 						__load_project ${BME_PROJECT_NAME}
# 					else
# 						echo "VAR DOES EXIST: ${!BME_PROJECT_NAME}"
# 						declare -n current_project=${BME_PROJECT_NAME}
# 						for key in "${!current_project[@]}"; do
# 							echo "$key => ${current_project[$key]}"
# 						done
# 					fi
	
# #  Let's make sure we are invoked only once
# 	if [[ -n ${PROJECT_DIR+x} ]]; then
# 		bme_log "Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} can only be called once per project session!" error
# 		return -1
# 	fi
# 	
# "Real" processing starts here
	source "${project_dir}/${BME_PROJECT_FILE}"
	bme_log "project ${C_BOLD}'${BME_PROJECT_NAME}'${C_NC} environment..." loading
	
# 	# First of all, let's "store" the project's "root dir" and "clean" PATH
# 	# Managing indirections for associative arrays in Bash is PITA.
# 	# Luckily, indirections come to the rescue
# 	declare -Ag ${project_name}
# 	declare -n current_project=${project_name}
# 	current_project['root_dir']="$PWD"
# 	current_project['previous_path']="${PATH}"
	export BME_PROJECT_DIR="${project_dir}"
	BME_ORIG_PATH=$PATH
# 	
# 	# Checks if current dir is within a git sandbox
# 	if git rev-parse --git-dir > /dev/null 2>&1; then
# 		BME_WITHIN_GIT=true
# 		# Checks .gitignore properties
# 		if ! git check-ignore -q "${BME_HIDDEN_DIR}/"; then
# 			bme_log "${C_BOLD}'${BME_HIDDEN_DIR}/'${C_NC} is not in your ${C_BOLD}'.gitignore'${C_NC} file.  You should add it." warning 1
# 		fi
# 		if ! [[ -d ${PROJECT_DIR}/${BME_HIDDEN_DIR} ]]; then
# 			bme_log "${C_BOLD}'${PROJECT_DIR}/${BME_HIDDEN_DIR}/'${C_NC} directory requested, but not found." warning 1
# 			mkdir ${PROJECT_DIR}/${BME_HIDDEN_DIR}
# 			bme_log "${C_BOLD}'${PROJECT_DIR}/${BME_HIDDEN_DIR}/'${C_NC} created." info 1
# 		fi
# 	else
# 		BME_WITHIN_GIT=false
# 		bme_log "Directory ${C_BOLD}'${PWD}'${C_NC} is not within a git sandbox." info 1
# 	fi
	
	# Loads modules
	if [[ -n ${BME_MODULES+x} ]]; then
		for module in "${BME_MODULES[@]}"; do
			if [ -r "${BASH_SOURCE}_modules/${module}.module" ]; then
				source "${BASH_SOURCE}_modules/${module}.module"
				${module}_load && ACTIVE_MODULES+=("${module}")
			else
				local log_msg="Couldn't load ${C_BOLD}'${module}'${C_NC} module.\n"
					log_msg+="\t\tFile ${C_BOLD}'${BASH_SOURCE}_modules/${module}.module'${C_NC} couldn't be found."
				bme_log "${log_msg}" warning 1
			fi
		done
		unset module
	fi
	
# 	# Checks for a valid custom clean function
# 	local custom_clean=`type -t bme_custom_clean`
# 	if [ -n "${custom_clean}" ] && [ "${custom_clean}" != 'function' ]; then
# 		bme_log "Custom clean object found, but it's not of type function: ${C_BOLD}'type -t bme_custom_clean: ${custom_clean}'${C_NC}." error 1
# 	fi
# 	
# 	# Show notice if 'check-version' module was requested
# 	[[ "${ACTIVE_MODULES[@]}" =~ 'check-version' ]] && check-version
# 	
# 	bme_log "Project ${C_BOLD}'${BME_PROJECT_NAME}'${C_NC} loaded.\n" info
# 	
# # Finally "re-run" the project's main BME_FILE, in case there is required code in-there
# 	source ${BME_FILE}
# # Print results
# 	for key in "${!current_project[@]}"; do
# 		echo "$key => ${current_project[$key]}"
# 	done
}


# Cleans project's environment
__bme_clean_project() {
# "pseudo private" function protection
local allowed_callers=('__bme_load_project' 'bme_eval_dir')
	if [[ ! " ${allowed_callers[*]} " =~ " ${FUNCNAME[1]} " ]]; then
		local log_msg="Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} is ${C_BOLD}private${C_NC}.  You shouldn't invoke it!\n"
		log_msg+="\tUnexpectedly called from ${C_BOLD}'${FUNCNAME[1]}'${C_NC}."
		bme_log "${log_msg}" error
		return -1
	fi
	
	local project_name="${BME_PROJECT_NAME}"
	
# # Custom clean (if any)
# 	local custom_clean=`type -t bme_custom_clean`
# 	if [ -n "${custom_clean}" ]; then
# 		if [ "${custom_clean}" == 'function' ]; then
# 			bme_custom_clean \
# 			&& bme_log "Custom clean function ended successfully" info 1 \
# 			|| bme_log "Custom clean function failed" error 1
# 			
# 			unset -f bme_custom_clean
# 		else
# 			bme_log "Custom clean object found, but it's not of type function: ${C_BOLD}'type -t bme_custom_clean: ${custom_clean}'${C_NC}." error 1
# 		fi
# 	fi
# Active modules
	if [[ -n ${ACTIVE_MODULES+x} ]]; then
		# List of active modules is processed in reverse order for deactivation, in case there are sorting dependencies
		# See https://stackoverflow.com/a/13360181/12237334 (hopefully this array will NOT have "holes" within)
		for (( module=${#ACTIVE_MODULES[@]}-1; module>=0; module-- )); do
			${ACTIVE_MODULES[module]}_unload
			unset -f ${ACTIVE_MODULES[module]}_load
			unset -f ${ACTIVE_MODULES[module]}_unload
		done
	fi
	unset module
	unset ACTIVE_MODULES
# Restore path
	PATH=$BME_ORIG_PATH
	unset BME_ORIG_PATH
# Final clean
	unset BME_WITHIN_GIT
	unset BME_PROJECT_NAME
	unset BME_PROJECT_DIR
	unset BME_MODULES
	bme_log "Project ${C_BOLD}'${project_name}'${C_NC} cleaned." cleaning
}


# Whitelists projects
__bme_whitelist() {
local test_path="${1}"

# "pseudo private" function protection
	if [ "${FUNCNAME[1]}" != 'bme_eval_dir' ]; then
		bme_log "Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} is ${C_BOLD}private${C_NC}.  You shouldn't invoke it!" error
		return -1
	fi
	
# Loads list of known directories
	if ! [ -v BME_WHITELISTED_PATHS[@] ]; then
	# BME_WHITELISTED_PATHS associative array not yet loaded
		if [ -r "${BME_WHITELISTED_FILE}" ]; then
			source "${BME_WHITELISTED_FILE}"
		else
		# First time configuration
			if ! [ -d "${BME_CONFIG_DIR}" ]; then
				bme_log "${C_BOLD}'${BME_CONFIG_DIR}'${C_NC} directory doesn't exist.  Creating it" info
				mkdir -p "${BME_CONFIG_DIR}"
			fi
			declare -gA BME_WHITELISTED_PATHS
		fi
	fi
	
# Checks whitelisting status of known directories
	local dir
	for dir in "${!BME_WHITELISTED_PATHS[@]}"; do
		# remember how this returns false if we are "within" a directory and true if not
		if ! [ "${test_path##$dir}" == "${test_path}" ]; then
			# returns the true/false allowance value associated with this directory
			return ${!BME_WHITELISTED_PATHS[$dir]}
		fi
	done
	
# If we reach here, it's a new directory
	bme_log "${C_BOLD}'${BME_FILE}'${C_NC} file found at ${C_BOLD}'${test_path}'${C_NC}." info
	echo -en 'Do you want to whitelist this directory? [y/N]: '
	while true; do
		read -r REPLY
		REPLY="${REPLY:-N}"  # reply defaults to 'N'
		REPLY="${REPLY^^}"   # then, turn the answer into uppercase
		case "${REPLY}" in
			Y)
				BME_WHITELISTED_PATHS["${test_path}"]+=true
				bme_log "Directory ${C_BOLD}'${test_path}'${C_NC} whitelisted!" info
				break
			;;
			N)
				BME_WHITELISTED_PATHS["${test_path}"]+=false
				bme_log "Directory ${C_BOLD}'${test_path}'${C_NC} rejected!" warning
				break
			;;
			*)
				# these control codes "overwrite" de console line
				echo -en "\r\033[1A\033[0K${C_RED}Only 'y' or 'n' allowed!${C_NC} Do you want to whitelist this directory? [y/N]: "
			;;
		esac
	done
	
	# finally, dump the new associative array to file and return the result
	echo "declare -gA BME_WHITELISTED_PATHS=(" > "${BME_WHITELISTED_FILE}"
		local dir
		for dir in "${!BME_WHITELISTED_PATHS[@]}"; do
			echo -e "\t[${dir}]=${BME_WHITELISTED_PATHS[$dir]}" >> "${BME_WHITELISTED_FILE}"
		done 
	echo ")" >> "${BME_WHITELISTED_FILE}"
	
	[ "$REPLY" == 'Y' ] && return $true || return $false
}


# Checks project name (since it'll become a variable name)
# 1st param: 'project_name': the project name to validate
__bme_check_project_name() {
local project_name=$1
local bad_name=false

# "pseudo private" function protection
	if [ "${FUNCNAME[1]}" != '__bme_process_known_projects' ]; then
		local log_msg="Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} is ${C_BOLD}private${C_NC}.  You shouldn't invoke it!\n"
		log_msg+="\tUnexpectedly called from ${C_BOLD}'${FUNCNAME[1]}'${C_NC}."
		bme_log "${log_msg}" error
		return -1
	fi

# Check for params
	if [[ -z "${project_name}" ]]; then
		local caller_data=`caller 0`
		local log_msg="${C_RED}(INTERNAL ERROR)${C_NC} Function ${C_BOLD}'${FUNCNAME[0]}'${C_NC} didn't get expected parameter ${C_BOLD}'project_name'${C_NC}.\n"
		log_msg+="\t${C_BOLD} FROM:${C_NC} ${caller_data}"
		bme_log "${log_msg}" fatal
		return -1
	fi
	
# There's a project name.  Now: is it valid?
# As per https://unix.stackexchange.com/questions/23659/can-shell-variable-name-include-a-hyphen-or-dash/23714
# A single "token" with only ASCII letters, numbers and underscore, and it can't start with a number
	# the project name should consist only on alnum or underscores
	local re="^([[:alnum:]]|_)+$"
	if [[ ! ${project_name} =~ $re ]]; then
		bme_log "${C_BOLD}'${project_name}'${C_NC} should only consist in alnum or underscores." fatal
		bad_name=true
	fi
	# the project name can't start with a number
	re="^[[:digit:]]"
	if [[ ${project_name} =~ $re ]]; then
		bme_log "${C_BOLD}'${project_name}'${C_NC} shouldn't start with a number." fatal
		bad_name=true
	fi
	
# exit on error
	if ($bad_name); then
		bme_log "${C_BOLD}'BME_PROJECT_NAME'${C_NC} should be a valid name (see above)." fatal
		return -1
	fi
}


# Checks if current path belongs to a known project
__bme_check_project_path() {
	local project
	for project in "${!BME_LOADED_PROJECTS[@]}"; do
		local project_root_dir="${BME_LOADED_PROJECTS[${project}]}"
		if ! [ "${PWD##$project_root_dir}" == "$PWD" ]; then
			echo "${project_root_dir}"
		fi
	done
}
