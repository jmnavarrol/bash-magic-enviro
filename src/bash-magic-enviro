# Main Bash Magic Enviro manager
#
# This file is meant to be sourced, not run
BME_SRC_DIR=<% BME_SRC_DIR %>
BME_VERSION=<% BME_VERSION %>
BME_FILE='.bme_env'
BME_HIDDEN_DIR='.bme.d'
BME_CONFIG_DIR="${HOME}/${BME_HIDDEN_DIR}"
BME_WHITELISTED_FILE="${BME_CONFIG_DIR}/whitelistedpaths.txt"

# Style table
export C_BOLD='\033[1m'         # Bold text
export C_GREEN='\033[1;32m'     # Green (and bold)
export C_YELLOW='\033[1;1;33m'  # Yellow (and bold)
export C_RED='\033[1;31m'       # Red (and bold)
export C_NC='\033[0m'           # No Color

# Sets 'fake' boolean
declare -i BOOL=(0 1)
true=${BOOL[0]}
false=${BOOL[1]}


#--
# FUNCTIONS
#--
# Main BME loader (it runs each time we change directory as per PROMPT_COMMAND)
bme_eval_dir() {
	if [ "$PWD" != "$MYOLDPWD" ]; then
		MYOLDPWD="$PWD"
		if [ -e ${BME_FILE} ]; then
			if __bme_whitelist "$PWD"; then
				source ${BME_FILE}
				# PROJECT_NAME must be the first thing to be set!!!
				if [[ -z ${PROJECT_NAME+x} ]]; then
					local log_msg="You didn't set ${C_BOLD}'PROJECT_NAME=[your_project_name]'${C_NC} in your ${C_BOLD}'${BME_FILE}'${C_NC} file.\n"
					log_msg+="\tDid you stop by your project's root directory first?"
					bme_log "${log_msg}" fatal
					return -1
				elif [[ -z ${PROJECT_DIR+x} ]]; then
				# If PROJECT_DIR is not set, it's because we just entered a new project enviroment
					__load_project
				fi
			else
				bme_log "${C_BOLD}'${BME_FILE}'${C_NC} file found, but load was rejected (see ${C_BOLD}'${BME_WHITELISTED_FILE}'${C_NC} contents)." warning
			fi
		fi
	# this conditional matches when we out of a project's root directory
		if [ "${PWD##$PROJECT_DIR}" == "$PWD" ] && [[ -n ${PROJECT_DIR+x} ]]; then
			__clean_project
		fi
	fi
}


# Logger function
# 1st param: 'log_message': the log message itself
# 2st param: 'log_type': log prefix, i.e.: ERROR, WARNING, empty string...
# 3st param: 'log_level': sets the indentation level of the log output, starting '0'
bme_log() {
local log_message="${1}"  # first param
local log_type="${2^^}"   # second param (uppercased)
local log_level=${3:-0}   # third param (with a default of 0)
local full_message=''
# Params debug
# 	echo "log_message: ${log_message}"
# 	echo "log_type: ${log_type}"
# 	echo "log_level: ${log_level}"

	if [ -z "$log_message" ]; then
		echo -e "${C_RED}FATAL:${C_NC} ${C_BOLD}'${FUNCNAME[0]}'${C_NC} called in code from ${C_BOLD}'${FUNCNAME[1]}'${C_NC} with no message."
		return -1
	fi
# Sets indentation level
	for (( i=0; i < ${log_level}; i++ )); do
		full_message+='\t'
	done
	unset i
# Then, message type
	case "$log_type" in
		FATAL | ERROR | FAIL)
			full_message+="${C_RED}${log_type}:${C_NC} "
		;;
		WARNING)
			full_message+="${C_YELLOW}${log_type}:${C_NC} "
		;;
		INFO | OK \
		| LOADING | CLEANING \
		| FUNCTION)
			full_message+="${C_GREEN}${log_type}:${C_NC} "
		;;
		*)
			if [ -n "$log_type" ]; then
				full_message+="${C_BOLD}${log_type}:${C_NC} "
			fi
		;;
	esac
# Finally, the message itself
	full_message+="${log_message}"
	
	echo -e "${full_message}"
}
export -f bme_log

# Loads a project's configuration
__load_project() {
# A bit of debug: I need to know the place I'm stored, so I can find other includes, relative to me
# 	echo "See what follows: $0"
# 	echo "See what follows: $_"
# 	echo "See what follows: ${BASH_SOURCE}"  # This is the good one! ~/bin/bash-magic-enviro
# 	echo "See what follows: ${BASH_SOURCE[0]}"
# 	echo "See what follows: ${BASH_SOURCE[${#BASH_SOURCE[@]} - 1]}"
# 	echo "See what follows: ${FUNCNAME[@]}"
	
# "pseudo private" function protection
	if [ "${FUNCNAME[1]}" != 'bme_eval_dir' ]; then
		bme_log "Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} is ${C_BOLD}private${C_NC}.  You shouldn't invoke it!" error
		return -1
	fi
#  Let's make sure we are invoked only once
	if [[ -n ${PROJECT_DIR+x} ]]; then
		bme_log "Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} can only be called once per project session!" error
		return -1
	fi
	
# "Real" processing starts here
	bme_log "project ${C_BOLD}'${PROJECT_NAME}'${C_NC} environment..." loading
	
	# First of all, let's "store" the project's "root dir" and "clean" PATH
	export PROJECT_DIR="$PWD"
	BME_ORIG_PATH=$PATH
	
	# Checks if current dir is within a git sandbox
	if git rev-parse --git-dir > /dev/null 2>&1; then
		BME_WITHIN_GIT=true
		# Checks .gitignore properties
		if ! git check-ignore -q "${BME_HIDDEN_DIR}/"; then
			bme_log "${C_BOLD}'${BME_HIDDEN_DIR}/'${C_NC} is not in your ${C_BOLD}'.gitignore'${C_NC} file.  You should add it." warning 1
		fi
		if ! [[ -d ${PROJECT_DIR}/${BME_HIDDEN_DIR} ]]; then
			bme_log "${C_BOLD}'${PROJECT_DIR}/${BME_HIDDEN_DIR}/'${C_NC} directory requested, but not found." warning 1
			mkdir ${PROJECT_DIR}/${BME_HIDDEN_DIR}
			bme_log "${C_BOLD}'${PROJECT_DIR}/${BME_HIDDEN_DIR}/'${C_NC} created." info 1
		fi
	else
		BME_WITHIN_GIT=false
		bme_log "Directory ${C_BOLD}'${PWD}'${C_NC} is not within a git sandbox." info 1
	fi
	
	# Loads modules
	if [[ -n ${BME_MODULES+x} ]]; then
		for module in "${BME_MODULES[@]}"; do
			if [ -r "${BASH_SOURCE}_modules/${module}.module" ]; then
				source "${BASH_SOURCE}_modules/${module}.module"
				${module}_load && ACTIVE_MODULES+=("${module}")
			else
				local log_msg="Couldn't load ${C_BOLD}'${module}'${C_NC} module.\n"
					log_msg+="\t\tFile ${C_BOLD}'${BASH_SOURCE}_modules/${module}.module'${C_NC} couldn't be found."
				bme_log "${log_msg}" warning 1
			fi
		done
		unset module
	fi
	
	# Checks for a valid custom clean function
	local custom_clean=`type -t bme_custom_clean`
	if [ -n "${custom_clean}" ] && [ "${custom_clean}" != 'function' ]; then
		bme_log "Custom clean object found, but it's not of type function: ${C_BOLD}'type -t bme_custom_clean: ${custom_clean}'${C_NC}." error 1
	fi
	
	# Show notice if 'check-version' module was requested
	[[ "${ACTIVE_MODULES[@]}" =~ 'check-version' ]] && check-version
	
	bme_log "Project ${C_BOLD}'${PROJECT_NAME}'${C_NC} loaded.\n" info
	
# Finally "re-run" the project's main BME_FILE, in case there is required code in-there
	source ${BME_FILE}
}


# Cleans project's environment
__clean_project() {
# "pseudo private" function protection
	if [ "${FUNCNAME[1]}" != 'bme_eval_dir' ]; then
		bme_log "Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} is ${C_BOLD}private${C_NC}.  You shouldn't invoke it!" error
		return -1
	fi
	
	local project_name="${PROJECT_NAME}"
	
# Custom clean (if any)
	local custom_clean=`type -t bme_custom_clean`
	if [ -n "${custom_clean}" ]; then
		if [ "${custom_clean}" == 'function' ]; then
			bme_custom_clean \
			&& bme_log "Custom clean function ended successfully" info 1 \
			|| bme_log "Custom clean function failed" error 1
			
			unset -f bme_custom_clean
		else
			bme_log "Custom clean object found, but it's not of type function: ${C_BOLD}'type -t bme_custom_clean: ${custom_clean}'${C_NC}." error 1
		fi
	fi
# Active modules
	if [[ -n ${ACTIVE_MODULES+x} ]]; then
		# List of active modules is processed in reverse order for deactivation, in case there are sorting dependencies
		# See https://stackoverflow.com/a/13360181/12237334 (hopefully this array will NOT have "holes" within)
		for (( module=${#ACTIVE_MODULES[@]}-1; module>=0; module-- )); do
			${ACTIVE_MODULES[module]}_unload
			unset -f ${ACTIVE_MODULES[module]}_load
			unset -f ${ACTIVE_MODULES[module]}_unload
		done
	fi
	unset module
	unset ACTIVE_MODULES
# Restore path
	PATH=$BME_ORIG_PATH
	unset BME_ORIG_PATH
# Final clean
	unset BME_WITHIN_GIT
	unset PROJECT_NAME
	unset PROJECT_DIR
	unset BME_MODULES
	bme_log "Project ${C_BOLD}'${project_name}'${C_NC} cleaned." cleaning
}


# Whitelists projects
__bme_whitelist() {
local test_path="${1}"

# "pseudo private" function protection
	if [ "${FUNCNAME[1]}" != 'bme_eval_dir' ]; then
		bme_log "Function ${C_BOLD}'${FUNCNAME[0]}()'${C_NC} is ${C_BOLD}private${C_NC}.  You shouldn't invoke it!" error
		return -1
	fi
	
# Loads list of known directories
	if ! [ -v BME_WHITELISTED_PATHS[@] ]; then
	# BME_WHITELISTED_PATHS associative array not yet loaded
		if [ -r "${BME_WHITELISTED_FILE}" ]; then
			source "${BME_WHITELISTED_FILE}"
		else
		# First time configuration
			if ! [ -d "${BME_CONFIG_DIR}" ]; then
				bme_log "${C_BOLD}'${BME_CONFIG_DIR}'${C_NC} directory doesn't exist.  Creating it" info
				mkdir -p "${BME_CONFIG_DIR}"
			fi
			declare -gA BME_WHITELISTED_PATHS
		fi
	fi
	
# Checks whitelisting status of known directories
	local dir
	for dir in "${!BME_WHITELISTED_PATHS[@]}"; do
		# remember how this returns false if we are "within" a directory and true if not
		if ! [ "${test_path##$dir}" == "${test_path}" ]; then
			# returns the true/false allowance value associated with this directory
			return ${!BME_WHITELISTED_PATHS[$dir]}
		fi
	done
	
# If we reach here, it's a new directory
	bme_log "${C_BOLD}'${BME_FILE}'${C_NC} file found at ${C_BOLD}'${test_path}'${C_NC}." info
	echo -en 'Do you want to whitelist this directory? [y/N]: '
	while true; do
		read -r REPLY
		REPLY="${REPLY:-N}"  # reply defaults to 'N'
		REPLY="${REPLY^^}"   # then, turn the answer into uppercase
		case "${REPLY}" in
			Y)
				BME_WHITELISTED_PATHS["${test_path}"]+=true
				bme_log "Directory ${C_BOLD}'${test_path}'${C_NC} whitelisted!" info
				break
			;;
			N)
				BME_WHITELISTED_PATHS["${test_path}"]+=false
				bme_log "Directory ${C_BOLD}'${test_path}'${C_NC} rejected!" warning
				break
			;;
			*)
				# these control codes "overwrite" de console line
				echo -en "\r\033[1A\033[0K${C_RED}Only 'y' or 'n' allowed!${C_NC} Do you want to whitelist this directory? [y/N]: "
			;;
		esac
	done
	
	# finally, dump the new associative array to file and return the result
	echo "declare -gA BME_WHITELISTED_PATHS=(" > "${BME_WHITELISTED_FILE}"
		local dir
		for dir in "${!BME_WHITELISTED_PATHS[@]}"; do
			echo -e "\t[${dir}]=${BME_WHITELISTED_PATHS[$dir]}" >> "${BME_WHITELISTED_FILE}"
		done 
	echo ")" >> "${BME_WHITELISTED_FILE}"
	
	[ "$REPLY" == 'Y' ] && return $true || return $false
}
